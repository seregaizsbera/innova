<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="ru" xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>Тестовое задание, описание реализации</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta http-equiv="Content-Style-Type" content="text/css"/>
  <meta name="Author" content="Сергей Богданов sergey-b@inbox.ru"/>
  <meta name="headers-numbering" content="false"/>
  <meta name="page-number-print-in-footer" content="true"/>
 </head>
 <body>
  <h3 id="description">Общее описание</h3>
   <p>
    Задание состоит из 3 программ: ProxyServer, EchoServer и InitiatorServer.
    Программы запакованы в один архив innova-task-x.x.x.jar и отличаются только стартовыми классами.
    Для запуска программ используются скрипты, в которых прописаны нужные имена классов.
   </p>

  <h3 id="build">Сборка</h3>
   <p>Для сборки запустите команду:</p>
   <pre>mvn package</pre>
   <p>Для сборки документации по Java-классам запустите команду:</p>
   <pre>mvn javadoc:javadoc</pre>

  <h3 id="launch">Запуск</h3>
   <p>Определите, на каком хосте будет работать ProxyServer и на каком порту. Далее, в примерах считается, что ProxyServer
   работает на одной машине с остальными программами и прослушивает порт 12345. Настройте переменную окружения PATH,
   так чтобы была доступна программа java версии 1.7 или выше. В примерах показаны команды для ОС Windows.
   </p>
   <p>Запустите в консоли команду</p>
   <pre>proxy-server.cmd 12345</pre>
   <p>Дождитесь сообщения <code>Enter command:</code>, наберите <code>start</code> и нажмите <code>Enter</code>.</p>

   <p>Запустите в другой консоли команду</p>
   <pre>echo-server.cmd loclalhost 12345 3 3</pre>
   <p>Дождитесь сообщения <code>Enter command:</code>, наберите <code>start</code> и нажмите <code>Enter</code>.</p>

   <p>Запустите в 3-й консоли команду</p>
   <pre>initiator-server.cmd loclalhost 12345 3 3</pre>
   <p>Дождитесь сообщения <code>Enter command:</code>, наберите <code>start</code> и нажмите <code>Enter</code>.
    В консоли с программой ProxyServer появится сообщение &laquo;The Initiator Server has started&raquo;.
   </p>

  <h3 id="implementation">Особенности реализации</h3>
   <p>Характерной особенностью задания является то, что прием и передача данных осуществляется одновременно несколькими
   потоками, причем количество потоков, передающих данные, и потоков, принимающих данные может различаться.
   Для хранения информации принятой потоками-получателями, до того как ее обработают потоки отправители, используются
   очереди.
   </p>
   <p>Для того чтобы удовлетворить требованию упорядоченного вывода данных в файлы, применяется специальная реализация
   очереди RingQueue. В эту очередь данные могут поступать в произвольном порядке, но выходят они строго последовательно.
   Для хранения данных, которые не могут быть отправлены из-за отсутствия более ранних значений, класс RingQueue использует
   массив. Если места в массиве не хватает, его размер увеличивается в 2 раза.
   </p>
   <p>
    Для передачи данных между программами используются TCP-сокеты. Каждый поток-отправитель и каждый поток-получатель
    устанавливает отдельное соединение с ProxyServer-ом. Потоки сообщают серверу о том, откуда они, и что намерены
    делать, при помощи специальных управляющих сообщений. Управляющие сообщения передаются по тому же соединению, что
    и основные данные. Поскольку передаваемые данные представляют собой целые числа, начинающиеся с 0, управляющие сообщения
    кодируются отрицательными целыми числами.
   </p>

  <h3 id="bottlenecks">Узкие места</h3>
   <p>Можно составить такой сценарий, при котором система развалится.</p>
   <ol>
    <li>proxy start</li>
    <li>echo start</li>
    <li>initiator start</li>
    <li>initiator stop</li>
    <li>initiator exit</li>
    <li>echo exit</li>
    <li>echo start</li>
    <li>initiator start</li>
   </ol>
   <p>После завершения 1-го экземпляра инициатора ProxyServer будет считать, что он все еще подключен.
   Когда к нему пойдут данные от 2-го экземпляра инициатора, часть из них ProxyServer попытается отправить
   в соединения, оставшиеся от 1-го экземпляра, и эти данные потеряются. 2-й экземпляр, не дождавшись одного из чисел,
   будет бесконечно копить новые данные в объекте RingQueue, пока у него не кончится память.
   </p>
   <p>Для решения этой проблемы, я делал отправку из прокси в инициатор специальных управляющих сообщений.
   Если клиент отключился, прокси об этом сразу же узнавал. Но я убрал из системы эту логику, потому
   что по условию задачи реализовывать такой сценарий не нужно, а мое решение снижало производительность.
   </p>

  <h3 id="issues">Недостатки</h3>
   <p>
   Поскольку управляющие сообщения передаются по тому же каналу, что и основные данные, прокси узнает о том,
   что инициатор остановился или завершился только после того, как обработает все числа, отправленные инициатором
   до возникновения события. Решить эту проблему можно, если держать для передачи управляющих сообщений 1 дополнительное
   соединение между инициатором и прокси, или передавать эти сообщения по UDP.
   </p>

   <p>Поскольку в каждой программе задания присутствуют похожие функции по копированию данных из сети в очередь и из
   очереди в сеть, то все программы используют общие классы.
   Один из таких общих классов — Receiver. Он должен работать одинаково во всех программах и не должен содержать логики,
   специфической для конкретного случая. Реализацию функций, которые делает только одна из программ, Receiver должен делегировать
   другим классам. Однако мне пришлось в этом классе реализовать вывод сообщений ProxyServer-а о событиях инициатора.
   В классе Receiver уже есть объект NetworkReceiver, реализующий логику, относящуюся к прокси, но он отвечает только
   за работу с сокетом, поэтому в нем делать обработку данных тоже неправильно. Поскольку на рефакторинг нет времени,
   я отметил неудачное место комментарием <code>TODO</code>.
   </p>

 </body>
</html>
